--[[ A script By makhail07


Discord Creterisk#2958 

Description:


]]--

local FavIDs = {340106355,927529620,876981900,398987889,1117396305}

function swait(num)
if num==0 or num==nil then
game:service'RunService'.Stepped:wait(0)
else
for i=0,num do
game:service'RunService'.Stepped:wait(0)
end
end
end
function thread(f)
  coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t) 
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	} 
	local ax, ay, az = a.x, a.y, a.z 
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t)) 
end
function QuaternionFromCFrame(cf)
  local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
  local trace = m00 + m11 + m22
  if trace > 0 then
    local s = math.sqrt(1 + trace)
    local recip = 0.5 / s
    return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
  else
    local i = 0
    if m00 < m11 then
      i = 1
    end
    if m22 > (i == 0 and m00 or m11) then
      i = 2
    end
    if i == 0 then
      local s = math.sqrt(m00 - m11 - m22 + 1)
      local recip = 0.5 / s
      return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
    elseif i == 1 then
      local s = math.sqrt(m11 - m22 - m00 + 1)
      local recip = 0.5 / s
      return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
    elseif i == 2 then
      local s = math.sqrt(m22 - m00 - m11 + 1)
      local recip = 0.5 / s
      return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
    end
  end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
  local xs, ys, zs = x + x, y + y, z + z
  local wx, wy, wz = w * xs, w * ys, w * zs
  local xx = x * xs
  local xy = x * ys
  local xz = x * zs
  local yy = y * ys
  local yz = y * zs
  local zz = z * zs
  return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
  local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
  local startInterp, finishInterp
  if cosTheta >= 1.0E-4 then
    if 1 - cosTheta > 1.0E-4 then
      local theta = math.acos(cosTheta)
      local invSinTheta = 1 / math.sin(theta)
      startInterp = math.sin((1 - t) * theta) * invSinTheta
      finishInterp = math.sin(t * theta) * invSinTheta
    else
      startInterp = 1 - t
      finishInterp = t
    end
  elseif 1 + cosTheta > 1.0E-4 then
    local theta = math.acos(-cosTheta)
    local invSinTheta = 1 / math.sin(theta)
    startInterp = math.sin((t - 1) * theta) * invSinTheta
    finishInterp = math.sin(t * theta) * invSinTheta
  else
    startInterp = t - 1
    finishInterp = t
  end
  return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
  return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end
--Wait what okay
wait()
local plr = game:service'Players'.LocalPlayer
local char = plr.Character
local hum = char.Humanoid
local ra = char["Right Arm"]
local la= char["Left Arm"]
local rl= char["Right Leg"]
local ll = char["Left Leg"]
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Magenta")
cf = CFrame.new
angles = CFrame.Angles
attack = false
euler=CFrame.fromEulerAnglesXYZ
equipped = false
necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CFrame.new(1.5, 0.5, 0)
RW.C1 = CFrame.new(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CFrame.new(-1.5, 0.5, 0)
LW.C1 = CFrame.new(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
print('User is '..plr.Name)
Effects = {}
	
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create

function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChildOfClass("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
         if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then
         warn'No R15 allowed'
         hit.Parent:FindFirstChild("Head"):BreakJoints()
         end

	if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil then
			if hit.Parent.DebounceHit.Value == true then
				return
			end
		end
         if insta == true then
         hit.Parent:FindFirstChild("Head"):BreakJoints()
         end
		local c = Create("ObjectValue"){
			Name = "creator",
			Value = game:service("Players").LocalPlayer,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil then
			if block.className == "IntValue" then
				if block.Value > 0 then
					blocked = true
					block.Value = block.Value - 1
					print(block.Value)
				end
			end
		end
		if blocked == false then
			h.Health = h.Health - Damage
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		else
			h.Health = h.Health - (Damage / 2)
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		end
		if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
			local bodvol = Create("BodyVelocity"){
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			local rl = Create("BodyAngularVelocity"){
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodvol, .5)
			game:GetService("Debris"):AddItem(rl, .5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity"){
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
			}
			if knockback > 0 then
				vp.Parent = hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, .5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, .5)
		elseif Type == "DarkUp" then
			coroutine.resume(coroutine.create(function()
				for i = 0, 1, 0.1 do
					swait()
					Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
				end
			end))
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition"){
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition"){
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			local BodGy = Create("BodyGyro") {
				maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
				P = 20e+003,
				Parent = hit.Parent.Torso,
				cframe = hit.Parent.Torso.CFrame,
			}
			hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part) 
				swait(1.5)
				Part.Anchored = false
			end), hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		local debounce = Create("BoolValue"){
			Name = "DebounceHit",
			Parent = hit.Parent,
			Value = true,
		}
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Create("ObjectValue"){
			Name = "creator",
			Value = Player,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
	end
end

function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Highway",
		TextColor3 = Color,
		TextScaled = true,
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=231917784", 1.2)
        end
      end
    end
  end
end
CFuncs = {
  Part = {
    Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
      local Part = Create("Part")({
        Parent = Parent,
        Reflectance = Reflectance,
        Transparency = Transparency,
        CanCollide = false,
        Locked = true,
        BrickColor = BrickColor.new(tostring(BColor)),
        Name = Name,
        Size = Size,
        Material = Material
      })
      RemoveOutlines(Part)
      return Part
    end
  },
  Mesh = {
    Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
      local Msh = Create(Mesh)({
        Parent = Part,
        Offset = OffSet,
        Scale = Scale
      })
      if Mesh == "SpecialMesh" then
        Msh.MeshType = MeshType
        Msh.MeshId = MeshId
      end
      return Msh
    end
  },
  Mesh = {
    Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
      local Msh = Create(Mesh)({
        Parent = Part,
        Offset = OffSet,
        Scale = Scale
      })
      if Mesh == "SpecialMesh" then
        Msh.MeshType = MeshType
        Msh.MeshId = MeshId
      end
      return Msh
    end
  },
  Weld = {
    Create = function(Parent, Part0, Part1, C0, C1)
      local Weld = Create("Weld")({
        Parent = Parent,
        Part0 = Part0,
        Part1 = Part1,
        C0 = C0,
        C1 = C1
      })
      return Weld
    end
  },
  Sound = {
    Create = function(id, par, vol, pit)
      coroutine.resume(coroutine.create(function()
        local S = Create("Sound")({
          Volume = vol,
          Pitch = pit or 1,
          SoundId = id,
          Parent = par or workspace
        })
        wait()
        S:play()
        game:GetService("Debris"):AddItem(S, 6)
      end))
    end
  },
  ParticleEmitter = {
    Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
      local fp = Create("ParticleEmitter")({
        Parent = Parent,
        Color = ColorSequence.new(Color1, Color2),
        LightEmission = LightEmission,
        Size = Size,
        Texture = Texture,
        Transparency = Transparency,
        ZOffset = ZOffset,
        Acceleration = Accel,
        Drag = Drag,
        LockedToPart = LockedToPart,
        VelocityInheritance = VelocityInheritance,
        EmissionDirection = EmissionDirection,
        Enabled = Enabled,
        Lifetime = LifeTime,
        Rate = Rate,
        Rotation = Rotation,
        RotSpeed = RotSpeed,
        Speed = Speed,
        VelocitySpread = VelocitySpread
      })
      return fp
    end
  }
}
function RemoveOutlines(part)
  part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
  local Part = Create("Part")({
    formFactor = FormFactor,
    Parent = Parent,
    Reflectance = Reflectance,
    Transparency = Transparency,
    CanCollide = false,
    Locked = true,
    BrickColor = BrickColor.new(tostring(BColor)),
    Name = Name,
    Size = Size,
    Material = Material
  })
  RemoveOutlines(Part)
  return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
  local Msh = Create(Mesh)({
    Parent = Part,
    Offset = OffSet,
    Scale = Scale
  })
  if Mesh == "SpecialMesh" then
    Msh.MeshType = MeshType
    Msh.MeshId = MeshId
  end
  return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
  local Weld = Create("Weld")({
    Parent = Parent,
    Part0 = Part0,
    Part1 = Part1,
    C0 = C0,
    C1 = C1
  })
  return Weld
end
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://431164262", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  }
}
function BlockEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
  local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  if Type == 1 or Type == nil then
    table.insert(Effects, {
      prt,
      "Block1",
      delay,
      x3,
      y3,
      z3,
      msh
    })
  elseif Type == 2 then
    table.insert(Effects, {
      prt,
      "Block2",
      delay,
      x3,
      y3,
      z3,
      msh
    })
  elseif Type == 3 then
    table.insert(Effects, {
      prt,
      "Block3",
      delay,
      x3,
      y3,
      z3,
      msh
    })
  end
end
function SphereEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = CreateMesh("SpecialMesh", prt, "Sphere", "nil", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {
    prt,
    "Cylinder",
    delay,
    x3,
    y3,
    z3,
    msh
  })
end
function RingEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
  prt.Anchored = true
  prt.CFrame = cframe * CFrame.new(x1, y1, z1)
  local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "264766957", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {
    prt,
    "Cylinder",
    delay,
    x3,
    y3,
    z3,
    msh
  })
end
function CylinderEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {
    prt,
    "Cylinder",
    delay,
    x3,
    y3,
    z3,
    msh
  })
end
function WaveEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = CreatePart(3, workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "264766957", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {
    prt,
    "Cylinder",
    delay,
    x3,
    y3,
    z3,
    msh
  })
end
function SpecialEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "24388358", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {
    prt,
    "Cylinder",
    delay,
    x3,
    y3,
    z3,
    msh
  })
end
function BreakEffect(brickcolor, cframe, x1, y1, z1)
  local prt = CreatePart(3, workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
  prt.Anchored = true
  prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
  local msh = CreateMesh("SpecialMesh", prt, "Sphere", "nil", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
  local num = math.random(10, 50) / 1000
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {
    prt,
    "Shatter",
    num,
    prt.CFrame,
    math.random() - math.random(),
    0,
    math.random(50, 100) / 100
  })
end
function CreateSound(ID, PARENT, VOLUME, PITCH)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = Instance.new("Sound", PARENT)
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NEWSOUND:play()
		game:GetService("Debris"):AddItem(NEWSOUND, 10)
	end))
	return NEWSOUND
end



local sine=0
function SHUTUP()
	attack = true
	hum.WalkSpeed = 0
	CreateSound("131829530", tors, 5, 1)
	for i = 0,2,0.1 do
		swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(5),math.rad(0),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(0)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(90), math.rad(0), math.rad(3)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(0), math.rad(-0), math.rad(-3)), 0.1)
	end
	for i = 0,1.2,0.1 do
		swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(0),math.rad(0),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(0)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(130), math.rad(0), math.rad(3)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(0), math.rad(-0), math.rad(-3)), 0.1)
	end
	for i = 0,2,0.1 do
		swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(5),math.rad(0),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(0)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(90), math.rad(0), math.rad(3)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(0), math.rad(-0), math.rad(-3)), 0.1)
	end
	attack = false
	hum.WalkSpeed = 16
end


function Huh()
	attack = true
	hum.WalkSpeed = 0
	CreateSound("1332262714", tors, 10, 1)
	for i = 0,6,0.1 do
		swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(0),math.rad(0),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(0),math.rad(15),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(0)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(0), math.rad(0), math.rad(150)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(0), math.rad(-0), math.rad(-150)), 0.1)
	end
	attack = false
	hum.WalkSpeed = 16
end

function Noni()
	attack = true
	hum.WalkSpeed = 0
	CreateSound("948494432", tors, 5, 1)
	for i = 0,6,0.1 do
		swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(-6),math.rad(0),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(-5),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(3)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-3)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(-120), math.rad(0), math.rad(115)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(-120), math.rad(-0), math.rad(-115)), 0.1)
	end
	attack = false
	hum.WalkSpeed = 16
end

function MeSwamp()
	attack = true
	hum.WalkSpeed = 0
	CreateSound("130767645", tors, 10, 1)
	for i = 0,6,0.1 do
		swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(0),math.rad(0),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(-5),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(3)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-3)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(-160), math.rad(0), math.rad(120)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(90), math.rad(-0), math.rad(-20)), 0.1)
	end
	for i = 0,2,0.1 do
		swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(5),math.rad(0),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(-5),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(3)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-3)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(-0), math.rad(0), math.rad(165)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(-0), math.rad(-0), math.rad(-165)), 0.1)
	end
	for i = 0,2,0.1 do
		swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(-5),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(3)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-3)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(-0), math.rad(0), math.rad(0)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(-0), math.rad(-0), math.rad(-0)), 0.1)
	end
	for i = 0,4,0.1 do
		swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(0),math.rad(360*i),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(-5),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(3)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-3)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(-0), math.rad(0), math.rad(90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(-0), math.rad(-0), math.rad(-90)), 0.1)
	end
	for i = 0,6,0.1 do
		swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(0),math.rad(0),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(-5),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),-.2)*RHCF*angles(math.rad(-5),math.rad(0),math.rad(3)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-3)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(-0), math.rad(0), math.rad(130)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(-0), math.rad(-0), math.rad(-130)), 0.1)
	end
	attack = false
	hum.WalkSpeed = 16
end


function EndMySuffering()
	attack = true
	hum.WalkSpeed = 0
	CreateSound("1096379637", tors, 5, 1)
	for i = 0,6,0.1 do
		swait()
		hum.Health = hum.Health + 50
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(0),math.rad(-10),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(25),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-0)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.3, 0.5+0.1*math.sin(sine/30), -0.6) * angles(math.rad(-0), math.rad(0), math.rad(-110)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(-0), math.rad(-0), math.rad(-100)), 0.1)
	end
	attack = false
	hum.WalkSpeed = 16
end


function WHATDAUSAY()
	attack = true
	hum.WalkSpeed = 0
	CreateSound("188381340", tors, 5, 1)
	for i = 0,20,0.1 do
		swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,math.random(-10, 10) / 100,-0.1+0.1*math.cos(sine/2))*angles(math.rad(20*math.cos(sine/2)),math.rad(20*math.cos(sine/2)),math.rad(20*math.cos(sine/2))),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(25),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-0)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(-0), math.rad(0), math.rad(-180*math.cos(sine/2))), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(-0), math.rad(-0), math.rad(-180*math.cos(sine/2))), 0.1)
	end
	for i = 0,2,0.1 do
		swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(0),math.rad(0),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-0)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(90), math.rad(0), math.rad(20)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(90), math.rad(-0), math.rad(-20)), 0.1)
	end
	for i = 0,2,0.1 do
		swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(0),math.rad(0),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-0)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(125), math.rad(0), math.rad(20)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(125), math.rad(-0), math.rad(-20)), 0.1)
	end
	Effects.Sphere.Create(maincolor, la.CFrame * CFrame.new(0, -2.2, 0), 100, 100, 100, 3, 3, 3, .1, .1)
Effects.Sphere.Create(maincolor, ra.CFrame * CFrame.new(0, -2.2, 0), 100, 100, 100, 3, 3, 3, .1, .1)
	for i = 0,2,0.1 do
		swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(0),math.rad(0),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-0)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(90), math.rad(0), math.rad(20)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(90), math.rad(-0), math.rad(-20)), 0.1)
	end
	attack = false
	hum.WalkSpeed = 16
end

function SippyBoy()
	attack = true
	hum.WalkSpeed = 0
local Blobby = Instance.new("Part", char)
Blobby.Name = "Blob"
Blobby.CanCollide = false
Blobby.BrickColor = BrickColor.new("Really black")
Blobby.Transparency = 1
Blobby.Material = "Plastic"
Blobby.Size = Vector3.new(1, 1, 2)
Blobby.TopSurface = Enum.SurfaceType.Smooth
Blobby.BottomSurface = Enum.SurfaceType.Smooth

local Weld = Instance.new("Weld", Blobby)
Weld.Part0 = ra
Weld.Part1 = Blobby
Weld.C1 = CFrame.new(0, -.1, 1)
Weld.C0 = CFrame.Angles(math.rad(-90),0,0)

local M2 = Instance.new("SpecialMesh")
M2.Parent = Blobby
M2.MeshId = "http://www.roblox.com/asset/?id=10470609"
M2.TextureId = "http://www.roblox.com/asset/?id=1219379224"
M2.Scale = Vector3.new(1,1,1)


Blobby.Transparency = 0
for i = 0,6,0.1 do
		swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(0),math.rad(-0),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-0)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), -0.6) * angles(math.rad(90), math.rad(0), math.rad(-0)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(-0), math.rad(-0), math.rad(-0)), 0.1)
end

CreateSound("1107256445", tors, 10, 1)
CreateSound("1107256445", tors, 10, 1)
CreateSound("1107256445", tors, 10, 1)
CreateSound("1107256445", tors, 10, 1)
for i = 0,10,0.1 do
		swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(0),math.rad(-0),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(-10),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-0)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.35, 0.7+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(115), math.rad(0), math.rad(-55)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(-0), math.rad(-0), math.rad(-0)), 0.1)
end
hum.WalkSpeed = 16
Blobby.Transparency = 1
attack = false
end

function GetOutOfMyCOcK()
	attack = true
	hum.WalkSpeed = 0
	CreateSound("1308566029", tors, 5, 1)
	local Cary = Instance.new("Part", char)
Cary.Name = "Blob"
Cary.CanCollide = false
Cary.BrickColor = BrickColor.new("Really black")
Cary.Transparency = 0
Cary.Material = "Plastic"
Cary.Size = Vector3.new(1, 1, 2)
Cary.TopSurface = Enum.SurfaceType.Smooth
Cary.BottomSurface = Enum.SurfaceType.Smooth

local Weld = Instance.new("Weld", Cary)
Weld.Part0 = tors
Weld.Part1 = Cary
Weld.C1 = CFrame.new(0, 0, 5)
Weld.C0 = CFrame.Angles(math.rad(0),math.rad(0),0)

local M2 = Instance.new("SpecialMesh")
M2.Parent = Cary
M2.MeshId = "http://www.roblox.com/asset/?id=591853691"
M2.TextureId = "http://www.roblox.com/asset/?id=591854066"
M2.Scale = Vector3.new(1,1,1)

for i = 0,2,0.1 do
		swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(0),math.rad(-0),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-0)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(120), math.rad(0), math.rad(-0)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(120), math.rad(-0), math.rad(-0)), 0.1)
end
Weld.C1 = CFrame.new(0, 0, 5)
Weld.C0 = CFrame.Angles(math.rad(0),math.rad(0),0)
for i = 0,10,0.1 do
		swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(0),math.rad(-0),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-0)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(90), math.rad(0), math.rad(-0)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(90), math.rad(-0), math.rad(-0)), 0.1)
end
Weld.C1 = CFrame.new(0, 0, 7)
Weld.C0 = CFrame.Angles(math.rad(90),math.rad(0),0)
for i = 0,14,0.1 do
		swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(0),math.rad(-0),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(-25),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-0)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(0), math.rad(0), math.rad(-180)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(0), math.rad(-0), math.rad(180)), 0.1)
end
for i = 1,8 do
Weld.C1 = CFrame.new(0, 0, 5)
Weld.C0 = CFrame.Angles(math.rad(0),math.rad(0),0)
for i = 0,1.2,0.1 do
		swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(0),math.rad(-0),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-0)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(90), math.rad(0), math.rad(-0)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(90), math.rad(-0), math.rad(-0)), 0.1)
end
Weld.C1 = CFrame.new(0, 0, 7)
Weld.C0 = CFrame.Angles(math.rad(90),math.rad(0),0)
for i = 0,1.2,0.1 do
	swait()
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(0),math.rad(-0),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(-25),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-0)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(0), math.rad(0), math.rad(180)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(0), math.rad(-0), math.rad(180)), 0.1)
end
end
attack = false
hum.WalkSpeed = 16
Cary.Transparency = 1
end


mouse.KeyDown:connect(function(key)
	if attack == false then
	if key == 'q' then
		SHUTUP()
	elseif key == 'e' then
		Huh()
	elseif key == 'r' then
		Noni()
	elseif key == 't' then
        MeSwamp()
	elseif key == 'y' then
		EndMySuffering()
	elseif key == 'f' then
		WHATDAUSAY()
	elseif key == 'z' then
		SippyBoy()
	elseif key == 'x' then
		GetOutOfMyCOcK()
		end
	end
end)


local idle=0
local change = 1
local val = 0
toim = 0
hum.Animator.Parent = nil
idleanim=.4
while true do
swait()
sine = sine + change
local torvel=(root.Velocity*Vector3.new(1,0,1)).magnitude 
local velderp=root.Velocity.y
hitfloor,posfloor=rayCast(root.Position,(CFrame.new(root.Position,root.Position - Vector3.new(0,1,0))).lookVector,4,char)
if equipped==true or equipped==false then
if attack==false then
idle=idle+1
else
idle=0
end
if root.Velocity.y > 1 and hitfloor==nil then 
Anim="Jump"
if attack==false then
rootj.C0 = clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))* angles(math.rad(10),math.rad(0),math.rad(0)),.3)
tors.Neck.C0 = clerp(tors.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(0)),.3)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(30), math.rad(0), math.rad(20)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-30)), 0.3)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),-0.3)*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(20)),0.15)
RH.C0=clerp(RH.C0,cf(1,-1,0.3)*angles(math.rad(0),math.rad(90),math.rad(-20)),.3)
end
elseif root.Velocity.y < -1 and hitfloor==nil then 
Anim="Fall"
if attack==false then
rootj.C0 = clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))* angles(math.rad(-5),math.rad(0),math.rad(0)),.3)
tors.Neck.C0 = clerp(tors.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(0)),.3)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(30), math.rad(0), math.rad(50)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-30), math.rad(0), math.rad(-50)), 0.3)
LH.C0=clerp(LH.C0,cf(-1,-.4-0.1*math.cos(sine/20),-.6)*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(20)),0.15)
RH.C0=clerp(RH.C0,cf(1,-.3-0.1*math.cos(sine/20),-.6)*angles(math.rad(0),math.rad(90),math.rad(-20)),.3)
end
elseif torvel<1 and hitfloor~=nil then
Anim="Idle"
change = 1
if attack==false then
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(0),math.rad(0),math.rad(0)),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(0)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(0), math.rad(0), math.rad(3)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(0), math.rad(-0), math.rad(-3)), 0.1)
end

elseif (tors.Velocity).magnitude < 50 and hitfloor ~= nil then
Anim="Walk"
change = 1
if attack==false then
rootj.C0=clerp(rootj.C0,RootCF*cf(0,0,-0.175+0.025*math.cos(sine/3.5)+ -math.sin(sine/3.5)/7)*angles(math.rad(3-2.5*math.cos(sine/3.5)),math.rad(0)+root.RotVelocity.Y/30,math.rad(17*math.cos(sine/7))+root.RotVelocity.Y/30),0.15)
tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-0.9-0.5*math.cos(sine/7)/2,0.055*math.cos(sine/7)/2)*angles(math.rad(0)+ -math.sin(sine/7)/1.5,math.rad(90-0.1*math.cos(sine/7)),math.rad(0)),0.15)
LH.C0=clerp(LH.C0,cf(-1,-0.9+0.5*math.cos(sine/7)/2,-0.055*math.cos(sine/7)/2)*angles(math.rad(0)+ math.sin(sine/7)/1.5,math.rad(-90-0.1*math.cos(sine/7)),math.rad(0)),0.15)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.04*math.sin(sine/25), 0) * angles(math.rad(120 )* math.cos(sine / 7), math.rad(-7*math.sin(sine/25)), math.rad(5)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.04*math.sin(sine/25),0) * angles(math.rad(-125 )* math.cos(sine / 7), math.rad(7*math.sin(sine/25)), math.rad(-5)), 0.1)
end
end
end





if 0 < #Effects then
    for e = 1, #Effects do
      if Effects[e] ~= nil then
        local Thing = Effects[e]
        if Thing ~= nil then
          local Part = Thing[1]
          local Mode = Thing[2]
          local Delay = Thing[3]
          local IncX = Thing[4]
          local IncY = Thing[5]
          local IncZ = Thing[6]
          if 1 >= Thing[1].Transparency then
            if Thing[2] == "Block1" then
              Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
              local Mesh = Thing[1].Mesh
              Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
              Thing[1].Transparency = Thing[1].Transparency + Thing[3]
            elseif Thing[2] == "Block2" then
              Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
              local Mesh = Thing[7]
              Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
              Thing[1].Transparency = Thing[1].Transparency + Thing[3]
            elseif Thing[2] == "Block3" then
              Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
              local Mesh = Thing[7]
              Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
              Thing[1].Transparency = Thing[1].Transparency + Thing[3]
            elseif Thing[2] == "Cylinder" then
              local Mesh = Thing[1].Mesh
              Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
              Thing[1].Transparency = Thing[1].Transparency + Thing[3]
            elseif Thing[2] == "Blood" then
              local Mesh = Thing[7]
              Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
              Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
              Thing[1].Transparency = Thing[1].Transparency + Thing[3]
            elseif Thing[2] == "Elec" then
              local Mesh = Thing[1].Mesh
              Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
              Thing[1].Transparency = Thing[1].Transparency + Thing[3]
            elseif Thing[2] == "Disappear" then
              Thing[1].Transparency = Thing[1].Transparency + Thing[3]
            elseif Thing[2] == "Shatter" then
              Thing[1].Transparency = Thing[1].Transparency + Thing[3]
              Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
              Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
              Thing[6] = Thing[6] + Thing[5]
            end
          else
            Part.Parent = nil
            table.remove(Effects, e)
          end
        end
      end
    end
  end
end